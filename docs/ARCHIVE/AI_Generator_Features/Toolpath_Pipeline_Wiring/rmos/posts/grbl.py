"""
GRBL Post-Processor

G-code post-processor for GRBL-compatible controllers.
Targets: ShapeOko, X-Carve, OpenBuilds, generic GRBL machines.

Registry Declaration:
    impl="app.rmos.posts.grbl:render"

Features:
- Metric units (G21)
- Absolute coordinates (G90)
- XY plane selection (G17)
- GRBL-compatible spindle control (M3/M5)
- Comment style with semicolons
- No line numbers (GRBL doesn't require them)
"""
from __future__ import annotations

from typing import Any, Dict, List, Optional
from datetime import datetime


def render(
    toolpaths: Dict[str, Any],
    context: Dict[str, Any],
    *,
    program_comment: Optional[str] = None,
) -> str:
    """
    Render toolpaths to GRBL-compatible G-code.
    
    Args:
        toolpaths: Toolpath data with segments
        context: Machine context (spindle_rpm, feed_rate, etc.)
    
    Returns:
        G-code string
    """
    lines: List[str] = []
    
    # Header
    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
    lines.append(f"; GRBL G-code generated by RMOS Studio")
    lines.append(f"; Generated: {timestamp}")
    if program_comment:
        lines.append(f"; {program_comment}")
    lines.append("")
    
    # Setup
    lines.append("G21 ; Units: mm")
    lines.append("G90 ; Absolute positioning")
    lines.append("G17 ; XY plane")
    lines.append("")
    
    # Extract parameters
    spindle_rpm = context.get("spindle_rpm", 12000)
    safe_z = context.get("safe_z_mm", 5.0)
    tool_id = context.get("tool_number", 1)
    
    # Tool change (optional for GRBL)
    if tool_id:
        lines.append(f"T{tool_id} ; Tool select")
    
    # Spindle on
    lines.append(f"S{spindle_rpm} M3 ; Spindle on CW at {spindle_rpm} RPM")
    lines.append(f"G4 P2 ; Dwell 2 seconds for spindle ramp")
    lines.append("")
    
    # Initial safe position
    lines.append(f"G0 Z{safe_z:.3f} ; Move to safe height")
    lines.append("")
    
    # Process toolpath segments
    segments = toolpaths.get("segments", [])
    moves = toolpaths.get("moves", [])
    
    if segments:
        lines.extend(_render_segments(segments, safe_z, context))
    elif moves:
        lines.extend(_render_moves(moves))
    else:
        lines.append("; No toolpath segments found")
    
    lines.append("")
    
    # Footer
    lines.append(f"G0 Z{safe_z:.3f} ; Retract to safe height")
    lines.append("M5 ; Spindle stop")
    lines.append("G0 X0 Y0 ; Return to origin")
    lines.append("M30 ; Program end")
    
    return "\n".join(lines)


def _render_segments(
    segments: List[Dict[str, Any]],
    safe_z: float,
    context: Dict[str, Any],
) -> List[str]:
    """Render segment-based toolpaths."""
    lines = []
    current_z = safe_z
    
    for i, seg in enumerate(segments):
        # Retract if needed
        if current_z < safe_z:
            lines.append(f"G0 Z{safe_z:.3f}")
            current_z = safe_z
        
        # Rapid to start position
        x_start = seg.get("x_start_mm", 0)
        y_start = seg.get("y_start_mm", 0)
        z_start = seg.get("z_start_mm", 0)
        x_end = seg.get("x_end_mm", x_start)
        y_end = seg.get("y_end_mm", y_start)
        z_end = seg.get("z_end_mm", z_start)
        feed = seg.get("feed_mm_per_min", context.get("feed_rate", 1000))
        
        lines.append(f"G0 X{x_start:.3f} Y{y_start:.3f} ; Segment {i+1}")
        
        # Plunge to start Z
        if z_start < current_z:
            lines.append(f"G1 Z{z_start:.3f} F{feed:.0f}")
            current_z = z_start
        
        # Cut to end position
        lines.append(f"G1 X{x_end:.3f} Y{y_end:.3f} Z{z_end:.3f} F{feed:.0f}")
        current_z = z_end
    
    return lines


def _render_moves(moves: List[Dict[str, Any]]) -> List[str]:
    """Render move-based toolpaths (from SawToolpathBuilder)."""
    lines = []
    
    for move in moves:
        code = move.get("code", "")
        
        # Build G-code line
        parts = [code]
        
        if move.get("x") is not None:
            parts.append(f"X{move['x']:.4f}")
        if move.get("y") is not None:
            parts.append(f"Y{move['y']:.4f}")
        if move.get("z") is not None:
            parts.append(f"Z{move['z']:.4f}")
        if move.get("f") is not None:
            parts.append(f"F{move['f']:.1f}")
        
        line = " ".join(parts)
        
        # Add comment
        if move.get("comment"):
            line += f" ; {move['comment']}"
        
        lines.append(line)
    
    return lines


# =============================================================================
# GRBL-specific utilities
# =============================================================================

def get_grbl_settings_report() -> Dict[str, Any]:
    """
    Return recommended GRBL settings for rosette/saw work.
    
    These are suggestions - actual values depend on machine.
    """
    return {
        "$0": 10,      # Step pulse (microseconds)
        "$1": 25,      # Step idle delay (ms)
        "$2": 0,       # Step port invert mask
        "$3": 0,       # Direction port invert mask
        "$4": 0,       # Step enable invert (0=active low)
        "$5": 0,       # Limit pins invert (0=active low)
        "$6": 0,       # Probe pin invert
        "$10": 1,      # Status report mask
        "$11": 0.010,  # Junction deviation (mm)
        "$12": 0.002,  # Arc tolerance (mm)
        "$13": 0,      # Report inches (0=mm)
        "$20": 0,      # Soft limits (0=off)
        "$21": 0,      # Hard limits (0=off)
        "$22": 0,      # Homing cycle (0=off)
        "$100": 250,   # X steps/mm
        "$101": 250,   # Y steps/mm
        "$102": 250,   # Z steps/mm
        "$110": 5000,  # X max rate (mm/min)
        "$111": 5000,  # Y max rate (mm/min)
        "$112": 2000,  # Z max rate (mm/min)
        "$120": 500,   # X acceleration (mm/sec^2)
        "$121": 500,   # Y acceleration (mm/sec^2)
        "$122": 200,   # Z acceleration (mm/sec^2)
        "$130": 300,   # X max travel (mm)
        "$131": 300,   # Y max travel (mm)
        "$132": 100,   # Z max travel (mm)
    }


def validate_for_grbl(gcode: str) -> List[str]:
    """
    Validate G-code for GRBL compatibility.
    
    Returns list of warnings/errors.
    """
    warnings = []
    lines = gcode.split("\n")
    
    unsupported = ["G43", "G44", "G41", "G42", "M98", "M99"]
    
    for i, line in enumerate(lines, 1):
        line = line.strip().upper()
        
        for cmd in unsupported:
            if cmd in line:
                warnings.append(f"Line {i}: {cmd} not supported by GRBL")
        
        # Check for canned cycles (G81-G89)
        for g in range(81, 90):
            if f"G{g}" in line:
                warnings.append(f"Line {i}: G{g} canned cycle not supported by GRBL")
    
    return warnings
