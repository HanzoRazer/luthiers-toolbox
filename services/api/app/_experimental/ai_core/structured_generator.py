# services/api/app/ai_core/structured_generator.py
"""
Constraint-aware rosette candidate generator.
Produces structured RosetteParamSpec candidates within constraint bounds.
"""

from __future__ import annotations

import math
import random
from typing import Any, Dict, Optional

from .generator_constraints import RosetteGeneratorConstraints
from .safety import coerce_to_rosette_spec

# Lazy imports to avoid circular dependencies
try:
    from ..rmos.api_contracts import RosetteParamSpec
except (ImportError, AttributeError, ModuleNotFoundError):
    from pydantic import BaseModel
    
    class RosetteParamSpec(BaseModel):  # type: ignore
        version: str = "1.0"
        rings: list = []
        notes: str = ""

try:
    from ..rmos.models import SearchBudgetSpec
except (ImportError, AttributeError, ModuleNotFoundError):
    from pydantic import BaseModel
    
    class SearchBudgetSpec(BaseModel):  # type: ignore
        max_attempts: int = 50
        time_limit_seconds: float = 30.0
        min_feasibility_score: float = 0.0
        stop_on_first_green: bool = True
        deterministic: bool = True


def _rng_for_attempt(deterministic: bool, attempt: int) -> random.Random:
    """
    Returns a Random instance that is stable across runs if deterministic=True.
    """
    if deterministic:
        return random.Random(10_000 + attempt)
    return random.Random()


def _ensure_rings_list(design: Dict[str, Any]) -> None:
    """Make sure design['rings'] exists and is a list."""
    rings = design.get("rings")
    if not isinstance(rings, list):
        design["rings"] = []


def _count_rings(design: Dict[str, Any]) -> int:
    rings = design.get("rings")
    if not isinstance(rings, list):
        return 0
    return len(rings)


def _total_ring_width_mm(design: Dict[str, Any]) -> float:
    """
    Try to estimate the total radial width from ring specs.
    Assumes each ring has a 'width_mm' field.
    """
    rings = design.get("rings")
    if not isinstance(rings, list):
        return 0.0

    total = 0.0
    for ring in rings:
        if not isinstance(ring, dict):
            continue
        w = ring.get("width_mm")
        if isinstance(w, (int, float)):
            total += float(w)
    return total


def _make_base_design(
    constraints: RosetteGeneratorConstraints,
    rng: random.Random,
) -> Dict[str, Any]:
    """
    Construct a minimal base rosette spec as a dict.
    """
    design: Dict[str, Any] = {
        "version": "1.0",
        "rings": [],
        "notes": "Generated by structured_generator scaffold.",
    }

    target_rings = rng.randint(constraints.min_rings, constraints.max_rings)

    for _ in range(target_rings):
        width = rng.uniform(constraints.min_ring_width_mm, constraints.max_ring_width_mm)
        ring: Dict[str, Any] = {
            "width_mm": round(width, 3),
            "material_key": constraints.palette_key,
            "pattern": "solid",
        }
        design["rings"].append(ring)

    return design


def _mutate_design_in_place(
    design: Dict[str, Any],
    constraints: RosetteGeneratorConstraints,
    rng: random.Random,
) -> None:
    """
    Apply a small, constraint-aware mutation to an existing design.
    """
    _ensure_rings_list(design)
    rings = design["rings"]
    ring_count = len(rings)

    if ring_count == 0:
        base = _make_base_design(constraints, rng)
        design.clear()
        design.update(base)
        return

    action = rng.choice(["adjust_width", "add_ring", "remove_ring"])

    if action == "adjust_width":
        idx = rng.randrange(0, ring_count)
        ring = rings[idx]
        if not isinstance(ring, dict):
            return

        current_width = ring.get("width_mm", constraints.min_ring_width_mm)
        delta = rng.uniform(-0.2, 0.2)
        new_width = float(current_width) + delta
        new_width = max(constraints.min_ring_width_mm, new_width)
        new_width = min(constraints.max_ring_width_mm, new_width)

        ring["width_mm"] = round(new_width, 3)

    elif action == "add_ring" and ring_count < constraints.max_rings:
        total_width = _total_ring_width_mm(design)
        if total_width < constraints.max_total_width_mm - constraints.min_ring_width_mm:
            width = rng.uniform(constraints.min_ring_width_mm, constraints.max_ring_width_mm)
            new_ring = {
                "width_mm": round(width, 3),
                "material_key": constraints.palette_key,
                "pattern": "solid",
            }
            insert_idx = rng.randint(0, ring_count)
            rings.insert(insert_idx, new_ring)

    elif action == "remove_ring" and ring_count > constraints.min_rings:
        remove_idx = rng.randrange(0, ring_count)
        del rings[remove_idx]

    # Clamp total width to max_total_width_mm
    total_width = _total_ring_width_mm(design)
    if total_width > constraints.max_total_width_mm and ring_count > 0:
        factor = constraints.max_total_width_mm / total_width
        for ring in rings:
            if not isinstance(ring, dict):
                continue
            w = ring.get("width_mm")
            if isinstance(w, (int, float)):
                new_w = max(constraints.min_ring_width_mm, float(w) * factor)
                ring["width_mm"] = round(new_w, 3)


def generate_constrained_candidate(
    *,
    prev_design: Optional[RosetteParamSpec],
    constraints: RosetteGeneratorConstraints,
    budget: Optional[SearchBudgetSpec] = None,
    attempt_index: int,
) -> RosetteParamSpec:
    """
    Main entry point for the constraint-aware generator.

    - If prev_design is present, mutate it slightly within constraints.
    - Otherwise, build a base design from constraints.
    - Honors SearchBudgetSpec.deterministic when available.
    """
    deterministic = False
    if budget is not None:
        deterministic = getattr(budget, "deterministic", False)

    rng = _rng_for_attempt(deterministic, attempt_index)

    if prev_design is not None:
        try:
            raw: Dict[str, Any] = prev_design.model_dump()
        except AttributeError:
            raw: Dict[str, Any] = dict(prev_design) if hasattr(prev_design, "__iter__") else {}
        _mutate_design_in_place(raw, constraints, rng)
    else:
        raw = _make_base_design(constraints, rng)

    return coerce_to_rosette_spec(raw)
