"""
Instrument Geometry: Scale Length & Fret Positions

Implements canonical equal-tempered fret spacing for a given scale length.

See docs/KnowledgeBase/Instrument_Geometry/Fret_Scale_Theory.md
for derivations, references, and assumptions.

Core Formula (12th Root of 2):
    The distance from the nut to the nth fret is:
        d_n = scale_length - scale_length / (2^(n/12))

    Or equivalently:
        d_n = scale_length * (1 - 1/(2^(n/12)))

    This is derived from equal temperament, where each semitone
    has a frequency ratio of 2^(1/12) ≈ 1.05946.

References:
    - https://www.liutaiomottola.com/formulae/fret.htm
    - Stewart-MacDonald fret scale calculator
    - "Guitar Making: Tradition and Technology" by Cumpiano & Natelson

Moved from: instrument_geometry/scale_length.py (Wave 14 reorg)
"""

from __future__ import annotations

import math
from dataclasses import dataclass
from math import pow as math_pow
from typing import List, Tuple, Dict, Any

# Constants
SEMITONE_RATIO = 2.0 ** (1.0 / 12.0)  # ≈ 1.05946309435929


def compute_fret_positions_mm(scale_length_mm: float, fret_count: int) -> List[float]:
    """
    Compute distance from the nut to each fret (in mm) for an equal-tempered
    instrument using the 12th-root-of-2 rule.

    Formula (distance from nut to nth fret):
        d_n = scale_length - scale_length / (2 ** (n / 12))
        d_n = scale_length * (1 - 2 ** (-n / 12))

    Args:
        scale_length_mm: Full scale length in millimeters (nut to bridge reference).
        fret_count: Number of frets to compute (e.g. 20, 21, 22, 24).

    Returns:
        List of length `fret_count`, where index 0 is the 1st fret, etc.
        Each value is the distance from the nut to that fret in mm.

    Raises:
        ValueError: If scale_length_mm <= 0 or fret_count <= 0.

    Example:
        >>> positions = compute_fret_positions_mm(648.0, 22)  # 25.5" Fender scale
        >>> round(positions[11], 2)  # 12th fret should be at half scale length
        324.0

    Common Scale Lengths:
        - Fender: 648.0 mm (25.5")
        - Gibson: 628.65 mm (24.75")
        - PRS: 635.0 mm (25")
        - Classical: 650.0 mm (25.6")
    """
    if scale_length_mm <= 0:
        raise ValueError("scale_length_mm must be > 0")
    if fret_count <= 0:
        raise ValueError("fret_count must be > 0")

    fret_positions: List[float] = []
    for n in range(1, fret_count + 1):
        # Distance from nut to nth fret
        ratio = math_pow(2.0, n / 12.0)
        position = scale_length_mm - (scale_length_mm / ratio)
        # Equivalent: position = scale_length_mm * (1 - 1/ratio)
        fret_positions.append(position)

    return fret_positions


def compute_fret_spacing_mm(scale_length_mm: float, fret_count: int) -> List[float]:
    """
    Compute the spacing between consecutive frets (in mm).

    This gives the distance from one fret to the next, useful for
    CNC slot cutting where you need incremental moves.

    Args:
        scale_length_mm: Full scale length in millimeters.
        fret_count: Number of frets to compute.

    Returns:
        List of length `fret_count`, where:
        - Index 0 is the distance from nut to 1st fret
        - Index 1 is the distance from 1st fret to 2nd fret
        - etc.

    Example:
        >>> spacings = compute_fret_spacing_mm(648.0, 22)
        >>> round(spacings[0], 2)  # First fret spacing (nut to 1st)
        36.4
        >>> round(spacings[11], 2)  # 12th fret spacing (11th to 12th)
        17.17
    """
    if scale_length_mm <= 0:
        raise ValueError("scale_length_mm must be > 0")
    if fret_count <= 0:
        raise ValueError("fret_count must be > 0")

    positions = compute_fret_positions_mm(scale_length_mm, fret_count)
    spacings: List[float] = []

    for i, pos in enumerate(positions):
        if i == 0:
            # Distance from nut (0) to first fret
            spacings.append(pos)
        else:
            # Distance from previous fret to current fret
            spacings.append(pos - positions[i - 1])

    return spacings


def compute_compensated_scale_length_mm(
    scale_length_mm: float,
    saddle_comp_mm: float,
    nut_comp_mm: float = 0.0,
) -> float:
    """
    Compute the effective scale length after saddle (and optional nut) compensation.

    Intonation compensation is needed because:
    1. Fretting a string increases its tension (sharpens pitch)
    2. String stiffness affects vibration (wound strings need more compensation)
    3. Action height affects stretch when fretting

    Args:
        scale_length_mm: Nominal scale length (nut to saddle reference).
        saddle_comp_mm: Saddle setback compensation (positive = longer).
        nut_comp_mm: Nut compensation (positive = shorter effective length).

    Returns:
        Compensated scale length in mm.

    Example:
        >>> compute_compensated_scale_length_mm(648.0, 2.5, 0.5)
        650.0
    """
    return scale_length_mm + saddle_comp_mm - nut_comp_mm


def compute_fret_to_bridge_mm(
    scale_length_mm: float,
    fret_number: int,
) -> float:
    """
    Compute the distance from a specific fret to the bridge.

    Useful for intonation calculations and pickup placement.

    Args:
        scale_length_mm: Full scale length in mm.
        fret_number: Fret number (1 = first fret, 12 = octave, etc.)

    Returns:
        Distance from the specified fret to the bridge in mm.

    Example:
        >>> round(compute_fret_to_bridge_mm(648.0, 12), 2)
        324.0  # 12th fret is exactly half scale length
    """
    if fret_number <= 0:
        return scale_length_mm  # From nut to bridge

    positions = compute_fret_positions_mm(scale_length_mm, fret_number)
    fret_position = positions[fret_number - 1]
    return scale_length_mm - fret_position


def compute_multiscale_fret_positions_mm(
    bass_scale_mm: float,
    treble_scale_mm: float,
    fret_count: int,
    string_count: int,
    perpendicular_fret: int = 0,
) -> List[List[Tuple[float, float]]]:
    """
    Compute fret positions for a multiscale (fanned fret) instrument.

    Each fret becomes a line segment connecting different positions
    on the bass and treble sides.

    Args:
        bass_scale_mm: Scale length on bass side.
        treble_scale_mm: Scale length on treble side.
        fret_count: Number of frets.
        string_count: Number of strings.
        perpendicular_fret: Which fret is perpendicular to strings (0 = nut).

    Returns:
        List of frets, where each fret is a list of (x, y) positions
        for each string position (bass to treble).

    Note:
        This is a simplified linear interpolation. Real multiscale
        instruments may use more complex fan patterns.
    """
    if bass_scale_mm <= 0 or treble_scale_mm <= 0:
        raise ValueError("Scale lengths must be > 0")
    if fret_count <= 0 or string_count <= 1:
        raise ValueError("fret_count must be > 0, string_count must be > 1")

    bass_positions = compute_fret_positions_mm(bass_scale_mm, fret_count)
    treble_positions = compute_fret_positions_mm(treble_scale_mm, fret_count)

    frets: List[List[Tuple[float, float]]] = []

    for fret_idx in range(fret_count):
        fret_line: List[Tuple[float, float]] = []
        bass_pos = bass_positions[fret_idx]
        treble_pos = treble_positions[fret_idx]

        for string_idx in range(string_count):
            # Linear interpolation from bass to treble
            t = string_idx / (string_count - 1)
            x_pos = bass_pos + (treble_pos - bass_pos) * t
            y_pos = t  # Normalized y-position (0 = bass, 1 = treble)
            fret_line.append((x_pos, y_pos))

        frets.append(fret_line)

    return frets


# Convenience: Common scale lengths in mm
SCALE_LENGTHS_MM = {
    "fender_standard": 648.0,      # 25.5"
    "gibson_standard": 628.65,     # 24.75"
    "prs_standard": 635.0,         # 25"
    "classical": 650.0,            # 25.6"
    "parlor": 609.6,               # 24"
    "baritone": 685.8,             # 27"
    "bass_standard": 863.6,        # 34"
    "bass_short": 762.0,           # 30"
    "mandolin": 349.25,            # 13.75"
    "banjo": 660.4,                # 26"
}

# Convenience: Common radius values in mm
RADIUS_VALUES_MM = {
    "vintage_fender": 184.15,      # 7.25"
    "modern_fender": 241.3,        # 9.5"
    "gibson": 304.8,               # 12"
    "prs": 254.0,                  # 10"
    "ibanez": 400.05,              # 15.75"
    "martin": 406.4,               # 16"
    "flat": float("inf"),          # Flat radius
}


# =============================================================================
# =============================================================================
# Wave 19: Fan-Fret (Multi-Scale) Calculations
# =============================================================================

# Perpendicular fret tolerance for floating-point precision (Phase E fix)
PERP_ANGLE_EPS = 1e-4


@dataclass
class FanFretPoint:
    """
    Represents a single fret position in a fan-fret system.
    
    Attributes:
        fret_number: Fret number (0 = nut, 1 = first fret, etc.)
        treble_pos_mm: Distance from nut on treble side (mm)
        bass_pos_mm: Distance from nut on bass side (mm)
        angle_rad: Fret angle in radians (0 = perpendicular to centerline)
        center_x: X position on centerline (mm from nut)
        center_y: Y position perpendicular offset (mm)
        is_perpendicular: Flag for designated perpendicular fret (tolerant to floating-point drift)
    """
    fret_number: int
    treble_pos_mm: float
    bass_pos_mm: float
    angle_rad: float
    center_x: float
    center_y: float
    is_perpendicular: bool = False


def compute_fret_position_standard(scale_length_mm: float, fret_number: int) -> float:
    """
    Calculate fret position for standard (non-fan) fretting using Rule of 18.
    
    Args:
        scale_length_mm: Scale length in millimeters
        fret_number: Fret number (1-24, 0 = nut)
    
    Returns:
        Distance from nut to fret in millimeters
    
    Example:
        >>> compute_fret_position_standard(648.0, 12)
        324.0  # Exactly half the scale length
    """
    if fret_number == 0:
        return 0.0
    
    return scale_length_mm * (1.0 - math_pow(2.0, -fret_number / 12.0))


def calculate_perpendicular_fret_intersection(
    treble_scale_mm: float,
    bass_scale_mm: float,
    target_fret: int = 7
) -> Tuple[float, float]:
    """
    Calculate the intersection point where the specified fret should be perpendicular.
    
    Args:
        treble_scale_mm: Scale length on treble (high E) side
        bass_scale_mm: Scale length on bass (low E) side
        target_fret: Which fret should be perpendicular (typically 7 or 8)
    
    Returns:
        Tuple of (treble_position, bass_position) in mm from nut
    
    Theory:
        For the perpendicular fret, both treble and bass positions are at the
        same distance from the nut, calculated as the average of the two scale lengths.
    """
    treble_pos = compute_fret_position_standard(treble_scale_mm, target_fret)
    bass_pos = compute_fret_position_standard(bass_scale_mm, target_fret)
    
    # For perpendicular fret, use average position
    avg_pos = (treble_pos + bass_pos) / 2.0
    
    return (avg_pos, avg_pos)


def compute_fan_fret_positions(
    treble_scale_mm: float,
    bass_scale_mm: float,
    fret_count: int,
    nut_width_mm: float,
    heel_width_mm: float,
    perpendicular_fret: int = 7,
    scale_length_reference_mm: float = None,
) -> List[FanFretPoint]:
    """
    Calculate complete fan-fret geometry with angled slots.
    
    This is the main function for Wave 19 fan-fret implementation.
    
    Args:
        treble_scale_mm: Scale length on treble (high E) side (e.g., 648.0 for 25.5")
        bass_scale_mm: Scale length on bass (low E) side (e.g., 686.0 for 27")
        fret_count: Total number of frets (typically 22 or 24)
        nut_width_mm: Fretboard width at nut (typically 42-44mm)
        heel_width_mm: Fretboard width at heel (typically 52-56mm)
        perpendicular_fret: Which fret remains perpendicular to centerline (typically 7 or 8)
        scale_length_reference_mm: Reference scale for radius blend (defaults to treble_scale_mm)
    
    Returns:
        List of FanFretPoint objects, one per fret (including fret 0 = nut)
    
    Example:
        >>> points = compute_fan_fret_positions(648.0, 686.0, 22, 42.0, 56.0, 7)
        >>> points[7].is_perpendicular
        True
        >>> abs(points[7].angle_rad) < 0.001
        True  # Perpendicular fret has near-zero angle
    """
    if scale_length_reference_mm is None:
        scale_length_reference_mm = treble_scale_mm
    
    fret_points: List[FanFretPoint] = []
    
    # Calculate perpendicular fret position (both sides equal)
    perp_treble, perp_bass = calculate_perpendicular_fret_intersection(
        treble_scale_mm, bass_scale_mm, perpendicular_fret
    )
    
    # Calculate Y positions (half-widths, since centerline is at Y=0)
    nut_half = nut_width_mm / 2.0
    heel_half = heel_width_mm / 2.0
    
    for fret_num in range(fret_count + 1):  # Include fret 0 (nut)
        # Calculate X positions (distance from nut)
        if fret_num == perpendicular_fret:
            # Perpendicular fret: both sides at same position
            treble_x = perp_treble
            bass_x = perp_bass
        else:
            # Regular fret: use respective scale lengths
            treble_x = compute_fret_position_standard(treble_scale_mm, fret_num)
            bass_x = compute_fret_position_standard(bass_scale_mm, fret_num)
        
        # Calculate average X for taper interpolation
        avg_x = (treble_x + bass_x) / 2.0
        
        # Estimate scale length position (0 at nut, 1 at bridge)
        scale_ratio = avg_x / treble_scale_mm if treble_scale_mm > 0 else 0.0
        scale_ratio = min(1.0, scale_ratio)  # Clamp to [0, 1]
        
        # Interpolate Y positions based on fretboard taper
        # Treble side is negative Y, bass side is positive Y
        treble_y = -1.0 * (nut_half + (heel_half - nut_half) * scale_ratio)
        bass_y = nut_half + (heel_half - nut_half) * scale_ratio
        
        # Calculate fret angle (deviation from perpendicular to centerline)
        # For fan-frets, we measure how much the fret deviates from 90° to centerline
        # This gives small angles (typically 0-5°) for multi-scale guitars
        
        # Distance from nut along centerline (X direction)
        dx = treble_x - bass_x  # Positive when treble is ahead of bass
        
        # Fretboard width at this position (Y direction, perpendicular to centerline)
        dy = bass_y - treble_y  # Full width from treble side to bass side
        
        if abs(dx) < 0.001:  # Perpendicular fret (or very close)
            angle_rad = 0.0
        else:
            # Angle = atan(opposite/adjacent) = atan(dx/dy)
            # This gives the deviation angle from perpendicular
            # Positive angle = treble side ahead (standard fan-fret orientation)
            angle_rad = math.atan(dx / dy) if abs(dy) > 0.001 else 0.0
        
        # Calculate center point
        center_x = avg_x
        center_y = (treble_y + bass_y) / 2.0
        
        # Determine if this is the perpendicular fret using tolerance check
        # This fixes floating-point precision issues in tests
        is_perp = (fret_num == perpendicular_fret) and (abs(angle_rad) < PERP_ANGLE_EPS)
        
        fret_point = FanFretPoint(
            fret_number=fret_num,
            treble_pos_mm=treble_x,
            bass_pos_mm=bass_x,
            angle_rad=angle_rad,
            center_x=center_x,
            center_y=center_y,
            is_perpendicular=is_perp,
        )
        
        fret_points.append(fret_point)
    
    return fret_points


def validate_fan_fret_geometry(
    treble_scale_mm: float,
    bass_scale_mm: float,
    fret_count: int,
    perpendicular_fret: int,
) -> Dict[str, Any]:
    """
    Validate fan-fret parameters before calculation.
    
    Args:
        treble_scale_mm: Treble scale length
        bass_scale_mm: Bass scale length
        fret_count: Total fret count
        perpendicular_fret: Perpendicular fret number
    
    Returns:
        Dict with keys: valid (bool), message (str), warnings (optional list)
    """
    warnings = []
    
    if treble_scale_mm <= 0:
        return {"valid": False, "message": "Treble scale length must be positive"}
    
    if bass_scale_mm <= 0:
        return {"valid": False, "message": "Bass scale length must be positive"}
    
    if bass_scale_mm < treble_scale_mm:
        return {"valid": False, "message": "Bass scale should be >= treble scale (standard convention)"}
    
    if perpendicular_fret < 0 or perpendicular_fret > fret_count:
        return {"valid": False, "message": f"Perpendicular fret must be between 0 and {fret_count}"}
    
    # Scale range check
    if treble_scale_mm < 500 or treble_scale_mm > 900:
        warnings.append(f"Treble scale ({treble_scale_mm:.1f}mm) is outside typical range (500-900mm)")
    
    if bass_scale_mm < 500 or bass_scale_mm > 900:
        warnings.append(f"Bass scale ({bass_scale_mm:.1f}mm) is outside typical range (500-900mm)")
    
    scale_diff = bass_scale_mm - treble_scale_mm
    if scale_diff > 100.0:
        warnings.append(f"Scale difference ({scale_diff:.1f}mm) is unusually large (>100mm)")
    
    result = {"valid": True, "message": "Fan-fret geometry is valid"}
    if warnings:
        result["warnings"] = warnings
    
    return result


# Common fan-fret configurations
FAN_FRET_PRESETS = {
    "7_string_standard": {
        "treble_scale_mm": 648.0,  # 25.5"
        "bass_scale_mm": 686.0,    # 27"
        "perpendicular_fret": 7,
        "description": "Standard 7-string multi-scale (25.5\"-27\")"
    },
    "8_string_standard": {
        "treble_scale_mm": 648.0,  # 25.5"
        "bass_scale_mm": 711.2,    # 28"
        "perpendicular_fret": 8,
        "description": "Standard 8-string multi-scale (25.5\"-28\")"
    },
    "baritone_6_string": {
        "treble_scale_mm": 660.0,  # 26"
        "bass_scale_mm": 685.8,    # 27"
        "perpendicular_fret": 7,
        "description": "Baritone 6-string multi-scale (26\"-27\")"
    }
}
