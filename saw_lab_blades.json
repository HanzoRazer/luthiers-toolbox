Nice, this is a good time to wire the “real blades + presets” into the Saw Lab pipeline.

Below is a small test harness that:

Loads real-ish blade + preset definitions from a JSON file

Instantiates SawBladeSpec + SawCutContext from those fixtures

Runs plan_basic_rip_cuts() and build_toolpath_plan_for_cuts()

Asserts that the whole Saw Lab skeleton executes cleanly for every preset

You’ll have two pieces:

A JSON fixture file with your blade/preset definitions

A pytest that uses that fixture to exercise the Saw Lab pipeline

1️⃣ Fixture file — real blade/preset definitions

Save this as:

tests/data/saw_lab_blades.json

{
  "blades": [
    {
      "id": "ultra_thin_140",
      "name": "Ultra-Thin Veneer Blade 140mm",
      "diameter_mm": 140.0,
      "kerf_mm": 1.0,
      "plate_mm": 0.8,
      "tooth_count": 80,
      "hook_angle_deg": 10.0,
      "top_grind": "Hi-ATB",
      "max_rim_speed_m_per_min": 90.0,
      "recommended_rim_speed_m_per_min": 70.0,
      "recommended_bite_mm_per_tooth": 0.15,
      "notes": "Primary production blade for veneer and rosette logs.",
      "presets": [
        {
          "name": "Gentle – Dense Hardwood",
          "feed_mm_per_min": 300.0,
          "rpm": 8000,
          "stock_length_mm": 600.0,
          "desired_piece_lengths_mm": [40.0, 40.0, 40.0]
        },
        {
          "name": "Normal – General Veneer",
          "feed_mm_per_min": 500.0,
          "rpm": 9000,
          "stock_length_mm": 800.0,
          "desired_piece_lengths_mm": [50.0, 50.0, 50.0]
        }
      ]
    },
    {
      "id": "veneer_160",
      "name": "Veneer / Panel Blade 160mm",
      "diameter_mm": 160.0,
      "kerf_mm": 1.2,
      "plate_mm": 0.9,
      "tooth_count": 96,
      "hook_angle_deg": 5.0,
      "top_grind": "ATB",
      "max_rim_speed_m_per_min": 100.0,
      "recommended_rim_speed_m_per_min": 75.0,
      "recommended_bite_mm_per_tooth": 0.18,
      "notes": "Secondary blade for longer veneer runs.",
      "presets": [
        {
          "name": "Gentle – Long Rip",
          "feed_mm_per_min": 300.0,
          "rpm": 7500,
          "stock_length_mm": 1200.0,
          "desired_piece_lengths_mm": [60.0, 60.0, 60.0]
        }
      ]
    }
  ],
  "material": {
    "id": "hardwood_generic",
    "name": "Generic Hardwood",
    "density_kg_per_m3": 720.0,
    "burn_tendency": 0.6,
    "tearout_tendency": 0.5,
    "hardness_scale": 0.7
  }
}


You can treat this as your first pass at a blade/preset library. Later you can generate this JSON from your DB or CSV tool tables.

2️⃣ Pytest harness — load fixtures and run the pipeline

Save this as:

tests/test_saw_lab_blades_and_presets.py


Adjust app. imports to match your package root if needed.

import json
from pathlib import Path

import pytest

from app.saw_lab.models import (
    SawBladeSpec,
    SawMaterialSpec,
    SawCutContext,
    SawLabConfig,
)
from app.saw_lab.path_planner import plan_basic_rip_cuts
from app.saw_lab.toolpath_builder import build_toolpath_plan_for_cuts
from app.saw_lab.risk_evaluator import evaluate_saw_risk


FIXTURE_PATH = Path(__file__).parent / "data" / "saw_lab_blades.json"


@pytest.fixture(scope="module")
def saw_lab_fixture():
    """Load blade + preset fixtures from JSON."""
    with FIXTURE_PATH.open("r", encoding="utf-8") as f:
        data = json.load(f)
    return data


@pytest.fixture(scope="module")
def material_spec(saw_lab_fixture):
    m = saw_lab_fixture["material"]
    return SawMaterialSpec(
        id=m["id"],
        name=m["name"],
        density_kg_per_m3=m.get("density_kg_per_m3"),
        burn_tendency=m.get("burn_tendency", 0.5),
        tearout_tendency=m.get("tearout_tendency", 0.5),
        hardness_scale=m.get("hardness_scale", 0.5),
    )


def build_cut_context_from_preset(blade_dict, preset_dict, material_spec):
    """Helper: convert JSON dicts into a SawCutContext instance."""
    blade = SawBladeSpec(
        id=blade_dict.get("id"),
        name=blade_dict["name"],
        diameter_mm=blade_dict["diameter_mm"],
        kerf_mm=blade_dict["kerf_mm"],
        plate_mm=blade_dict["plate_mm"],
        tooth_count=blade_dict["tooth_count"],
        hook_angle_deg=blade_dict.get("hook_angle_deg", 0.0),
        top_grind=blade_dict.get("top_grind"),
        max_rim_speed_m_per_min=blade_dict.get("max_rim_speed_m_per_min"),
        recommended_rim_speed_m_per_min=blade_dict.get("recommended_rim_speed_m_per_min"),
        recommended_bite_mm_per_tooth=blade_dict.get("recommended_bite_mm_per_tooth"),
        notes=blade_dict.get("notes"),
    )

    ctx = SawCutContext(
        blade=blade,
        material=material_spec,
        # Let planner fall back to RIP for now; you can wire cut modes later.
        feed_mm_per_min=preset_dict["feed_mm_per_min"],
        rpm=preset_dict["rpm"],
        stock_length_mm=preset_dict["stock_length_mm"],
        desired_piece_lengths_mm=preset_dict["desired_piece_lengths_mm"],
    )
    return ctx


def test_fixture_file_exists_and_parses(saw_lab_fixture):
    """Sanity check that the JSON fixture is present and well-formed."""
    assert "blades" in saw_lab_fixture
    assert isinstance(saw_lab_fixture["blades"], list)
    assert len(saw_lab_fixture["blades"]) > 0

    assert "material" in saw_lab_fixture
    assert "name" in saw_lab_fixture["material"]


def test_each_blade_preset_yields_toolpath_plan(saw_lab_fixture, material_spec):
    """
    Core harness: for every blade and every preset in the fixture,
    build a SawCutContext and ensure the Saw Lab pipeline runs end-to-end.
    """
    blades = saw_lab_fixture["blades"]
    config = SawLabConfig()

    for blade_dict in blades:
        presets = blade_dict.get("presets", [])
        assert presets, f"Blade {blade_dict['id']} must have at least one preset defined"

        for preset in presets:
            ctx = build_cut_context_from_preset(blade_dict, preset, material_spec)

            # --- Risk evaluation must not crash ---
            risk_summary = evaluate_saw_risk(ctx, config)
            assert 0.0 <= risk_summary.max_risk <= 1.0

            # --- Path planning must produce at least one cut ---
            stock_outline = "DUMMY_STOCK_OUTLINE"
            cuts = plan_basic_rip_cuts(ctx, stock_outline)
            assert cuts, f"No cuts generated for preset {preset['name']}"

            # --- Toolpath plan must contain operations & runtime ---
            plan = build_toolpath_plan_for_cuts(ctx, cuts)
            assert plan is not None
            assert "operations" in plan
            assert isinstance(plan["operations"], list)
            assert len(plan["operations"]) > 0

            assert "total_estimated_runtime_min" in plan
            total_rt = plan["total_estimated_runtime_min"]
            assert isinstance(total_rt, (int, float))
            assert total_rt >= 0.0


@pytest.mark.parametrize("blade_id", ["ultra_thin_140", "veneer_160"])
def test_specific_blade_has_presets(saw_lab_fixture, blade_id):
    """
    Spot-check that specific blades we care about really have presets defined.
    This protects against accidentally deleting/editing them later.
    """
    blades = saw_lab_fixture["blades"]
    blade = next((b for b in blades if b["id"] == blade_id), None)
    assert blade is not None, f"Blade {blade_id} not found in fixture"

    presets = blade.get("presets", [])
    assert len(presets) > 0, f"Blade {blade_id} should have presets defined"

How this helps you

This is a real test harness: it loads a data file, builds real SawCutContext objects, and runs the actual Saw Lab pipeline (risk → plan → toolpath plan).

As you scale to more blades, presets, and material types, you just add to the JSON and the test suite automatically covers them.

When you eventually replace stubs with real geometry + physics, this harness will catch any regressions where a blade/preset combo becomes invalid or crashes the pipeline.